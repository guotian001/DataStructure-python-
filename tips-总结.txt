1.  写算法，需要一张草稿纸，在草稿纸上弄一个具体的小例子，尽可能多的包含到信息（测试样例），
    比照着这个小例子进行编码，由具体到一般。
    不然凭空想象直接去写的话，现在境界还没到，而且也没有必要，何苦给自己加大难度呢，问题简单化，善假于物也
2.

    # 搞不清楚的时候，找张纸，清晰的画出过程，比如引用变量啦，下标变量的迭代更替啦，边界问题啦，具体的过程清晰地走一遍，这些问题都能轻易的解决
    # 一定要把变量指到哪里了搞搞清楚，因为这涉及到边界的问题，
    # 结合着个具体的小例子（将例子清晰的走一遍下来），就能轻易的将这些过程写出来，虽然如果不结合过程来看这些代码 仍然是不clear的
    # 也就是说：不论写还是看算法的代码，都最好结合个具体的小例子（测试样例），尤其当你搞不太清楚的时候
    # 由具体到一般
    # 找张草稿纸先，
3.  递归，描述出来过程（拆出来的可以看成一个同样的问题，只是规模缩小了点），定义清楚出口，然后，"bong",结果就出来了
    类似方程思想，我们把方程写出来，计算机来解方程，返回给我们答案

4. # 如果某个判断条件描述起来较麻烦的话，不如转向其对立条件，让后将该条件下的操作放在else中（一般比较麻烦的条件其对立条件可能比较简单）

5. 最笨的方法，将流程步骤用代码实现出来

6. # 对象作为参数在方法体内改变后，重新赋值一次是最保险的，不用担心值传递引起的问题。反正重新赋值一次是肯定能可以的
    eg： tree = None
        tree = insert(tree, "haha")
         # insert(tree, "haha") × ， 在方法体内改变了tree，并不能改变方法体外的tree，因为，是值传递，即仅仅是将体外的tree的值赋值给了
         方法体的形参，体内的tree是一个新的临时变量，只不过其初始值与体外的变量的值相同而已，因此，改变体内的临时变量不会影响体外的tree。

        ！！！解决方法！！： 将体内的临时变量返回出去，对体外的变量重新赋值。如tree = insert(tree, "haha")（insert中  有return tree）